// Copyright Â© 2019 Kubeedge <EMAIL ADDRESS>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"fmt"
	"io"

	"github.com/kubeedge/kubeedge/kubeedgeinst/cmd/options"
	"github.com/kubeedge/kubeedge/kubeedgeinst/cmd/phases/workflow"

	"github.com/lithammer/dedent"
	"github.com/spf13/cobra"
	flag "github.com/spf13/pflag"
	"k8s.io/apimachinery/pkg/util/sets"
)

var (
	joinLongDescription = dedent.Dedent(`
		When joining a kubeedge initialized cluster, we need to establish
		bidirectional trust. This is split into discovery (having the Node
		trust with the Kubeedge Master)

		`)
)

// joinOptions defines all the options exposed via flags by kubeadm join.
// Please note that this structure includes the public kubeedge config API, but only a subset of the options
// supported by this api will be exposed as a flag.
type JoinOptions struct {
	cfgPath               string
	token                 string
	controlPlane          bool
	ignorePreflightErrors []string
	//externalcfg           *kubeadmapiv1beta1.JoinConfiguration
	certificateKey string
	server         string
}

// compile-time assert that the local data object satisfies the phases data interface.

// joinData defines all the runtime information used when running the kubeadm join worklow;
// this data is shared across all the phases that are included in the workflow.
type joinData struct {
	//cfg                   *kubeadmapi.JoinConfiguration
	skipTokenPrint bool
	//initCfg               *kubeadmapi.InitConfiguration
	//tlsBootstrapCfg       *clientcmdapi.Config
	//clientSet             *clientset.Clientset
	ignorePreflightErrors sets.String
	outputWriter          io.Writer
	certificateKey        string
}

// NewCmdJoin returns "kubeadm join" command.
// NB. joinOptions is exposed as parameter for allowing unit testing of
//     the newJoinData method, that implements all the command options validation logic
func NewCmdJoin(out io.Writer, joinOptions *JoinOptions) *cobra.Command {
	if joinOptions == nil {
		joinOptions = newJoinOptions()
	}
	joinRunner := workflow.NewRunner()

	cmd := &cobra.Command{
		Use:   "join",
		Short: "Run this on any machine you wish to join an existing cluster",
		Long:  joinLongDescription,
		Run: func(cmd *cobra.Command, args []string) {
			fmt.Println("in node join")

		},
		// We accept the control-plane location as an optional positional argument
		Args: cobra.MaximumNArgs(1),
	}

	//addJoinConfigFlags(cmd.Flags(), joinOptions.externalcfg)
	addJoinOtherFlags(cmd.Flags(), joinOptions)

	//joinRunner.AppendPhase(phases.NewPreflightPhase())

	// sets the data builder function, that will be used by the runner
	// both when running the entire workflow or single phases
	joinRunner.SetDataInitializer(func(cmd *cobra.Command, args []string) (workflow.RunData, error) {
		return newJoinData(cmd, args, joinOptions, out)
	})

	// binds the Runner to kubeadm join command by altering
	// command help, adding --skip-phases flag and by adding phases subcommands
	joinRunner.BindToCommand(cmd)

	return cmd
}

// addJoinConfigFlags adds join flags bound to the config to the specified flagset

// addJoinOtherFlags adds join flags that are not bound to a configuration file to the given flagset
func addJoinOtherFlags(flagSet *flag.FlagSet, joinOptions *JoinOptions) {
	flagSet.StringVar(
		&joinOptions.cfgPath, options.CertPath, joinOptions.cfgPath,
		"downloaded path of the certifcates generated by cloud component in this host (Mandatory)",
	)
	flagSet.StringSliceVar(
		&joinOptions.ignorePreflightErrors, options.DockerVersion, joinOptions.ignorePreflightErrors,
		"use this key to download and use the required Docker version (Optional, default will be Latest)",
	)

	flagSet.StringVar(
		&joinOptions.certificateKey, options.KubeedgeVersion, "",
		"use this key to download and use the required KubeEdge version (Optional, default will be Latest)",
	)
	flagSet.StringVar(
		&joinOptions.certificateKey, options.Kubernetesversion, "",
		"use this key to download and use the required Kubernetes version (Optional, default will be Latest)",
	)
	flagSet.StringVar(
		&joinOptions.server, options.Server, "",
		"ip:port address of cloud components host/VM (Mandatory)",
	)
}

// newJoinOptions returns a struct ready for being used for creating cmd join flags.
func newJoinOptions() *JoinOptions {
	// initialize the public kubeEdge config API by applying defaults

	// Add optional config objects to host flags.
	// un-set objects will be cleaned up afterwards (into newJoinData func)

	// Apply defaults
	//kubeadmscheme.Scheme.Default(externalcfg)

	return &JoinOptions{
		//externalcfg: externalcfg,
	}
}

// newJoinData returns a new joinData struct to be used for the execution of the kubeedge node join workflow.
// This func takes care of validating joinOptions passed to the command, and then it converts
// options into the internal JoinConfiguration type that is used as input all the phases in the kubeadm join workflow
func newJoinData(cmd *cobra.Command, args []string, opt *JoinOptions, out io.Writer) (*joinData, error) {
	// Re-apply defaults to the public kubeadm API (this will set only values not exposed/not set as a flags)
	//kubeadmscheme.Scheme.Default(opt.externalcfg)

	// Validate standalone flags values and/or combination of flags and then assigns
	// validated values to the public kubeadm config API when applicable

	// if a token is provided, use this value for both discovery-token and tls-bootstrap-token when those values are not provided
	if len(opt.token) > 0 {
		//add logic
	}

	// if a file or URL from which to load cluster information was not provided, unset the Server.File object
	//if len(opt.externalcfg.Discovery.File.KubeConfigPath) == 0 {
	//	opt.externalcfg.Discovery.File = nil
	//}

	// if an APIServerEndpoint from which to retrieve cluster information was not provided, unset the Discovery.BootstrapToken object
	if len(args) == 0 {
		//add logic
	}

	// if not joining a control plane, unset the ControlPlane object
	if !opt.controlPlane {

	}

	// if the admin.conf file already exists, use it for skipping the discovery process.
	// NB. this case can happen when we are joining a control-plane node only (and phases are invoked atomically)
	//var adminKubeConfigPath = kubeadmconstants.GetAdminKubeConfigPath()

	return &joinData{
		//tlsBootstrapCfg:       tlsBootstrapCfg,
		//ignorePreflightErrors: ignorePreflightErrorsSet,
		outputWriter:   out,
		certificateKey: opt.certificateKey,
	}, nil
}

// CertificateKey returns the key used to encrypt the certs.
func (j *joinData) CertificateKey() string {
	return j.certificateKey
}

// IgnorePreflightErrors returns the list of preflight errors to ignore.
func (j *joinData) IgnorePreflightErrors() sets.String {
	return j.ignorePreflightErrors
}

// OutputWriter returns the io.Writer used to write messages such as the "join done" message.
func (j *joinData) OutputWriter() io.Writer {
	return j.outputWriter
}
